Command 1: cd Desktop
Command 2: g++ urfilename.cpp
Command 3: ./a.out                                        			
					
					
					//Assignment no. 1

/*A book consists of chapters, chapters consist of sections and sections consist of
subsections. Construct a tree and print the nodes. Find the time and space requirements
of your method.*/
                                      
#include <iostream>
using namespace std;

struct node         //Node declaration
{
    char label[10];
    int ch_count;
    struct node *child[10];  //pointer to the Array
}*root;

class GeneralTree
{
    public:
    void create_tree();
    void display_tree(node *r1);

    GeneralTree()
    {
        root=NULL;
    }
};

void GeneralTree::create_tree()
{ int i,j,k,tbooks, tchapters;

  root=new node();        //Node is created

  cout<<"Enter name of Book: ";
  cin>>root->label;

  cout<<"Enter total no. of chapters in book: ";
  cin>>tchapters;
  root->ch_count=tchapters;

  for(i=0; i<root->ch_count; i++)
    {
        root->child[i]=new node;
        cout<<"Enter name of the chapters: ";
        cin>>root->child[i]->label;

        cout<<"Enter total no. of sections in chapter: ";
        cin>>root->child[i]->ch_count;

        for(j=0; j<root->child[i]->ch_count; j++)
            {
               root->child[i]->child[j]=new node;
               cout<<"Enter head of section: ";
               cin>>root->child[i]->child[j]->label;

            }
    }
}

void GeneralTree::display_tree(node * r1)
{
    int i,j,k,tchapters;
    if(r1 != NULL)
        {
            cout<<"\n---Book Hierarchy---\n";

            cout<<"\n Book Title: "<<r1->label;
            tchapters= r1->ch_count;
            for(i=0; i<tchapters; i++)
                {
                    cout<<"\n Chapter "<<i+1<<":";
                    cout<<"\n "<<r1->child[i]->label;
                    cout<<"\n Sections: ";
                    for(j=0; j<r1->child[i]->ch_count; j++)
                        {
                            cout<<"\n "<<r1->child[i]->child[j]->label;

                        }
                }
        }
}


int main()
{
    int choice;
    GeneralTree T1;
//T1.create_tree();
   // T1.display_tree(root);

    do
    {
        cout<<"\n***Book Tree Creation***";
        cout<<"\n 1.Create";
        cout<<"\n 2.Display";
        cout<<"\n 3.Quit";
        cout<<"\n Enter your choice: ";
        cin>>choice;



    switch(choice)
    {
    case 1:
        T1.create_tree();
        break;
    case 2:
        T1.display_tree(root);
        break;
    case 3:
        exit(1);
    default:
        cout<<"\n Wrong choice";
    }
} while(choice!=3);

}

                                   //Assignment no. 2

/*Department maintains a student information. The file contains roll number, name, division and address.
Allow user to add, delete information of student. Display information of particular students.
If record of student does not exist an appropriate message is displayed. If it is,
then the system displays the student details.
*/

                                  
#include<iostream>
#include<fstream>
#include<cstdio>

using namespace std;

class student
{
    public:

    int rollno;
    char name[50];
    char add[50];
    char div[5];


    void setData()
    {
        cout<<"Enter Roll no: ";
        cin>>rollno;
        cout<<"Enter Name: ";
        cin>>name;
        cout<<"Address of student: ";
        cin>>add;
        cout<<"Division of student: ";
        cin>>div;
    }

    void showData()
    {
        cout<<"\n Roll no. of student: "<<rollno;
        cout<<"\n Name of the student: "<<name;
        cout<<"\n Address of student: "<<add;
        cout<<"\n Division of student: "<<div;
    }

    int retrollno()
    {
        return rollno;
    }
};

void write_record()
{
    ofstream outfile;
    outfile.open("StudentData", ios::binary | ios::app);

    student obj;
    obj.setData();
    outfile.write((char*)&obj, sizeof(obj));
    outfile.close();
}

void display_record()
{
    ifstream infile;
    infile.open("StudentData", ios::binary);

    student obj;

    while(infile.read((char*)&obj, sizeof(obj)))
        {
            obj.showData();
        }
    infile.close();
}

void search_record(int n)
{
    bool flag=false;
    ifstream infile;
    infile.open("StudentData", ios::binary);

    student obj;


    while (infile.read((char*)&obj, sizeof(obj)))
    {
        if(obj.rollno==n)
        {
            cout<<"Record for entered roll no. is found in the file.";
            flag=true;
            obj.showData();
            break;
        }

    }
    if(flag==false)
        {
            cout<<"Record for entered roll no. is not found in the file.";
        }
}

void delete_record(int n)
{
    student obj;


    ifstream infile;
    infile.open("StudentData", ios::binary);

    ofstream outfile;
    outfile.open("StudentNewData", ios::out | ios::binary);

    while(infile.read((char*)&obj, sizeof(obj)))
    {
        if(obj.retrollno() != n)
        {
            outfile.write((char*)&obj, sizeof(obj));
        }
    }
    infile.close();
    outfile.close();
    remove("StudentData");
    rename("StudentNewData","StudentData");
}

int main()
{
    int ch;
    do
    {
        cout<<"\n******File Operations******\n 1.Add Record. \n 2.Display Record. \n 3.Search a particular Record. \n 4.Delete particular Record. \n 5.Exit";

        cout<<"\n Enter your choice: ";
        cin>>ch;
        switch(ch)
        {
        case 1:
            cout<<"Enter total no. of records you want to store in a file: ";
            int n;
            cin>>n;
            for(int i=0; i<n; i++)
            {
                write_record();
            }
            break;
        case 2:
            cout<<"\n List of records: ";
            display_record();
            break;
        case 3:
            cout<<"Enter student roll no. whose record you want search: ";
            int s;
            cin>>s;
            search_record(s);
            break;
        case 4:
            cout<<"Enter student roll no. whose record you want delete: ";
            int t;
            cin>>t;
            delete_record(t);
            cout<<"Record Deleted Successfully!!";
            break;
        case 5:
            return 0;
        }
    }while(ch!=6);
}


                                         //Assignment no. 3

/*Beginning with an empty binary search tree, Construct binary search tree by inserting
the values in the order given. After constructing a binary tree -
i. Insert new node, ii. Find number of nodes in longest path from root, iii. Minimum data
value found in the tree, iv. Change a tree so that the roles of the left and right pointers
are swapped at every node, v. Search a value*/


# include<iostream>
using namespace std;
class Node
{
public:
    int key;
    Node *ln, *rn;
};

class Tree
{
public:

    Node* root;     //root is a ptr and it is of node type
    BST()
    {
        root=NULL;
    }


    Node* createTree(int key)//this fun return ptr of type node
    {
        Node* root=new Node();
        root->key= key;
        root->ln=NULL;
        root->rn=NULL;
        return root;

    }

    void insertNode(int key, Node* root)
    {
        Node* newNode=new Node();
        newNode->key=key;
        if(root->key>key)
        {
            if(root->ln==NULL)
            {
                root->ln=newNode;
            }
            else
            {
                insertNode(key, root->ln);
            }
        }

        if(root->key<key)
        {
            if(root->rn==NULL)
            {
                root->rn=newNode;
            }
            else
            {
                insertNode(key, root->rn);
            }
        }
    }

    void displayInorder(Node* root)
    {
        if(root!=NULL)
        {
            displayInorder(root->ln);
            cout<<root->key<<endl;
            displayInorder(root->rn);
        }
    }

    void descending (Node * root)
    {
        if (root != NULL)
        {
            descending (root->rn);
            cout << "\n" << root->key;
            descending (root->ln);
        }
    }


    void displayMin(Node* root)
    {
        while (root->ln != NULL)
        {
            root=root->ln;
        }
        cout<<"\n Minimum number is "<<root->key;
    }

    void search(Node* root, int searchKey)
    {
        if(searchKey == root->key)
            {
                cout<<"Search Successful. Number Found."<<endl;
            }
        else if(searchKey < root->key)
        {
            if(root->ln != NULL)
            {
                search(root->ln , searchKey);
            }
            else
            {
                cout<<"Number not found!";
            }

        }
        else if(searchKey > root->key)
            {
                if(root->rn !=NULL)
                {
                    search(root->rn , searchKey);
                }
                else
                {
                    cout<<"Number not found!";
                }
            }
        else
            {
                cout<<"Element Not Present in the Tree"<<endl;

            }
     }

    int longestPath(Node* root)
    {
        if(root==NULL)
        {
            return 0;
        }
        int Lctr=longestPath(root->ln);
        int Rctr=longestPath(root->rn);
        if(Lctr>Rctr)
        {
            return (Lctr+1);
        }
        else
        {
            return(Rctr+ 1);
        }
    }



            Node* swapNode(Node* root)
            {
                Node* temp;
                if(root==NULL)
                {
                    return NULL;
                }
                temp= root->ln;
                root->ln=root->rn;
                root->rn=temp;
                swapNode(root->ln);
                swapNode(root->rn);
            }
};

int main()
{
    int choice, order, flag=0;
    int key, searchKey;
    string n="y";
    Tree t1;
    Node* root;
    do
    {
        cout<<"\n1. Enter a number \n2. Display \n3. Search \n4. Swap left and right node. \n5. Exit.";
        cout<<"\nEnter your choice: ";
        cin>>choice;
        switch(choice)
        {
            case 1:
                do
                {
                    cout<<"\n Enter the number: ";
                    cin>>key;

                if(flag==0)
                {
                    root=t1.createTree(key);
                    flag=1;

                }
                else
                {
                    t1.insertNode(key,root);
                }
                cout<<"If you want to enter more numbers (y) else enter (n): ";
                cin>>n;
                }while(n=="y");

                break;

            case 2:
                cout<<"\n1. Display list in ascending order. \n2. Display list descending order. \n3. Show min no. \n4. Show no of nodes in longest path";
                cout<<"\nEnter your choice: ";
                cin>>order;
                switch(order)
                {
                case 1:
                    t1.displayInorder(root);
                    break;
                case 2:
                    t1.descending(root);
                    break;
                case 3:
                    t1.displayMin(root);
                    break;
                case 4:
                    cout<<"Height of the tree or the longest path is: "<<t1.longestPath(root);
                    break;
                }

                break;

            case 3:
                cout<<"Enter the no. you want to search: ";
                cin>>searchKey;
                t1.search(root, searchKey);
                break;

            case 4:
                t1.swapNode(root);
                cout<<"Swapped!! the new list is: \n";
                t1.displayInorder(root);
                break;

            case 5:
                break;

        }
    }while(choice!=5);
     return 0;
}


                                                     //Assignment no. 4

/*A Dictionary stores keywords & its meanings. Provide facility for adding new keywords, deleting keywords, updating values
of any entry. Provide facility to display whole data sorted in ascending/ Descending order. Also find how many maximum
comparisons may require for finding any keyword. Use Binary Search Tree for implementation.*/


#include<iostream>
#include<string>
#include<cstring>
#include<cstdlib>

using namespace std;
int op;

class node
{
public:
    char word[50], mean[50];
    node*left;
    node*right;
};

class BST
{
public:
    node*root;
    BST()
    {
        root=NULL;
    }

    void create();
    node*insert(node*, node*);
    void inorder(node*);
    void search(node*, char[]);
    void modify(node*,char[]);
    node *dlt(node*, char[]);
};

void BST::create()
{
    int op;
    node* temp;
    do
    {
        temp=new node;
        cout<<"Enter a word which you want to store in tree node: ";
        cin>>temp->word;
        cout<<"Enter a meaning: ";
        cin>>temp->mean;
        temp->left=NULL;
        temp->right=NULL;
        if(root==NULL)
        {
            root=temp;
        }
        else
        {
            insert(root,temp);
        }
        cout<<"Enter 1 to again insert a new node else enter any other number: ";
        cin>>op;
    }while(op==1);
}

node* BST::insert(node* root, node* temp)
{
    if(strcmp(temp->word, root->word)<0)
    {
        if(root->left==NULL)
        {
            root->left=temp;
        }
        else
        {
            insert(root->left,temp);
        }
    }
    else
    {
       if(root->right==NULL)
        {
            root->right=temp;
        }
       else
        {
            insert(root->right,temp);
        }
    }
return root;
}

void BST::inorder(node* temp)
{
    if(temp!=NULL)
    {
        inorder(temp->left);
        cout<<temp->word<<" : "<<temp->mean<<"\n";
        inorder(temp->right);
    }
}

void BST::search(node*temp,char src[])
{
    if(temp!=NULL)
    {
        if((strcmp(temp->word, src)== 0))
           {
               cout<<"\n Word Found ";
               cout<<"\n Word : "<<temp->word;
               cout<<"\n Meaning : "<<temp->mean<<"\n";
           }
        else if((strcmp(temp->word, src)!= 0))
            {
               if((strcmp(temp->word, src)< 0))
                  {
                      search(temp->right, src);
                  }
               else if((strcmp(temp->word, src)> 0))
                  {
                      search(temp->left, src);
                  }
            }
    }
    else
    {
        cout<<"Word not found!!";
    }
}

void BST::modify(node*temp, char src[])
{
    if(temp!=NULL)
    {
        if((strcmp(temp->word, src)== 0))
           {
               cout<<"\n Word Found ";
               cout<<"\n Enter new meaning of Word "<<temp->word<<" : ";
               cin>>temp->mean;
           }
        else if((strcmp(temp->word, src)!= 0))
            {
               if((strcmp(temp->word, src)< 0))
                  {
                      modify(temp->right, src);
                  }
               else if((strcmp(temp->word, src)> 0))
                  {
                      modify(temp->left, src);
                  }
            }
    }
    else
    {
        cout<<"Word not found!!";
    }
}

node *minimum(node*root){
        while(root->left==NULL)
        {
            root=root->left;
        }
        return root;

    }


node* BST::dlt(node*root,char src[])
{


    if(root!= NULL)
    {
        if((strcmp(root->word , src))>0)
        {
            root->left=dlt(root->left, src);
        }
        else if((strcmp(root->word , src))<0)
        {
            root->right=dlt(root->right, src);
        }
        else
        {
            if(root->left==NULL && root->right==NULL)
            {
                delete(root);
                root=NULL;
                cout<<"Word deleted successfully.";
            }
            else if(root->left==NULL)
            {
                node* temp=root;
                root=root->right;
                delete(temp);
                cout<<"Word deleted successfully.";
            }
            else if(root->right==NULL)
            {
                node* temp=root;
                root=root->left;
                delete(temp);
                cout<<"Word deleted successfully.";
            }
            else
            {
                node *temp=root->right;
                strcpy(root->word, temp->word);
                strcpy(root->mean, temp->mean);
                root->right=dlt(root->right,temp->word);
            }
      }
    }return root;
}

int main()
{
    BST b;
    int op;
    char src[100];
    while(1)
    {
        cout<<"\n ";
        cout<<"\n 1. Insert Binary Search Tree";
        cout<<"\n 2. Display Inorder";
        cout<<"\n 3. Search a particular word";
        cout<<"\n 4. Modify the meaning of word";
        cout<<"\n 5. Delete the word from Dictionary";
        cout<<"\n 6. Exit";

        cout<<"\n Enter your choice: ";
        cin>>op;
        switch(op)
        {
        case 1:
            b.create();
            break;

        case 2:
            cout<<"Inorder Traversal of Tree : \n";
            b.inorder(b.root);
            break;

        case 3:
            cout<<"\n Enter the word which you want to search in given tree: ";
            cin>>src;
            b.search(b.root , src);
            break;

        case 4:
            cout<<"\n Enter the word which you want to modify: ";
            cin>>src;
            b.modify(b.root , src);
            break;

        case 5:
            cout<<"Enter the word which you want to delete: ";
            cin>>src;
            b.dlt(b.root,src);
            break;

        case 6:
            break;

        default:
            cout<<"\n Invalid Option!!";
            break;
        }
    }
}


                                      //Assignment no. 5

/*Consider telephone book database of N clients. Make use of a hash table
implementation to quickly look up client‘s telephone number. Make use of two collision
handling techniques and compare them using number of comparisons required to find a
set of telephone numbers.*/

                                 

#include <iostream>
#include <string>

using namespace std;

class telephone
{
    public:

    int mobile[10];
    int address;
    long long key;
    string name[10];

    /*telephone()
    {
        int i;
        for(i=0;i<10;i++)
        {
            mobile[i]=-1;
            name[i]="AB";
        }
    }*/

    void insertrecord_linearly()
    {
        int i;
        for(i=0;i<10;i++)
        {
            mobile[i]=-1;
            name[i]="AB";
        }

        string n="y";
        do
        {
        cout<<"Enter the mobile number: ";
        cin>>key;
        address=key%10;

        while(1)
            {
                if(mobile[address]==-1)
                {
                    mobile[address]=key;
                    cout<<"Enter name for this mobile number: ";
                    cin>>name[address];
                    break;
                }
                else
                    {
                        address++;
                        if(address==10)
                        {
                            address=0;
                        }
                    }
            }

        int cnt=0;
        for(int k=0;k<10;k++)
            {
                if(mobile[k]!=-1)
                {
                     cnt++;
                }
            }
        if(cnt==10)
            {
                cout<<"Hash table is full. You cannot store more Records!!";
            }
        cout<<"If you want to enter next mobile no. then enter (y) else enter (n): ";
        cin>>n;

        }while(n=="y");
    }


    void insertrecord_Quadratically()
    {
        int i;
        for(i=0;i<10;i++)
        {
            mobile[i]=-1;
            name[i]="AB";
        }

        string n="y";
        do
        {
        cout<<"Enter the mobile no.";
        cin>>key;
        address=key%10;

        if(mobile[address]==-1)
        {
            mobile[address]=key;
            cout<<"Enter name for this mobile no.";
            cin>>name[address];

        }
        else
        {
           //when collision occurs....
            int j=1;
            while(1)
                {
                    int t = (address + j * j) % 10;
                    if (mobile[t] == -1)
                    {
                        mobile[t] = key;
                        cout<<"Enter name for this mobile no.";
                        cin>>name[address];
                        break;
                    }
                    else
                    {
                        j++;
                    }

                }
        }

        int cnt=0;
        for(int k=0;k<10;k++)
        {
            if(mobile[k]!=-1)
            {
               cnt++;
            }


        }
        if(cnt==10)
        {
            cout<<"Hash table is full. You cannot store more Records!!";
        }
        cout<<"If you want to enter next mobile no. then enter (y) else enter (n): ";
        cin>>n;
        }while(n=="y");
    }

    void display()
    {
        int i;
        cout<<"\n***Displaying Records***"<<"\n";
        for(i=0; i<10; i++)
        {
           cout<<"Index="<<i<<"\n";
           cout<<"Mob no. ="<<mobile[i]<<"\n";
           cout<<"Name: "<<name[i]<<"\n";
        }
    }


};


int main()
{
    int choice;
    telephone obj1;
    do
    {
        cout<<"\n1. Insert record using linear probe. \n2. Insert record using Quadratic probe. \n3. Display Record \n4. Exit.";
        cout<<"\nEnter your choice: ";
        cin>>choice;
        switch(choice)
        {
            case 1:
                obj1.insertrecord_linearly();
                break;
            case 2:
                obj1.insertrecord_Quadratically();
                break;
            case 3:
                obj1.display();
            case 4:
                break;
        }

    }while(choice!=4);
    return 0;
}


                                          //Assignment no. 6                                     
          
/*There are flight paths between cities. If there is a flight between city A and city B then
there is an edge between the cities. The cost of the edge can be the time that flight take
to reach city B from A, or the amount of fuel used for the journey. Represent this as a
graph. The node can be represented by airport name or name of the city. Use adjacency
list representation of the graph or use adjacency matrix representation of the graph.
Check whether the graph is connected or not. Justify the storage representation used.*/


#include <iostream>
#include <string>
using namespace std;

class Graph
{
    public:
    int n,f,i,city1,city2;
    int j;
    string cities[100];
    int fuel;
    int graph[100][100];

    Graph()
    {
       for(i=0;i<n;i++)
       {
           for(j=0;j<n;j++)
           {
               graph[i][j]=0;

           }
        }
    }

    void create()
    {
        cout<<"Enter total no. of cities: ";
        cin>>n;

        for(i=0;i<n;i++)
        {
            cout<<"Enter name of city: ";
            cin>>cities[i];

        }

        cout<<"Use following numbers for the respective cities: "<<endl;
        for(i=0;i<n;i++)
        {
            cout<<cities[i]<<"="<<i<<endl;

        }

        cout<<"Enter total no. of flites available: ";
        cin>>f;

        for(i=0;i<f;i++)
        {
            cout<<"Enter the numbers of respectives cities for which flite is available:  "<<endl;
            cout<<"city1=";
            cin>>city1;
            cout<<"city2=";
            cin>>city2;

            cout<<"Enter the fuel required for respective flite(in liter): ";
            cin>>fuel;
            graph[city1][city2]=fuel;

        }
    }
    void display()
    {
        for (int i = 0; i < n; i++)
            cout << "\t" << cities[i] << "\t";
        for (int i = 0; i < n; i++)
        {
            cout << "\n"<< cities[i];
            for (int j = 0; j < n; j++)
                cout << "\t" << graph[i][j] << "\t";

        }
    }


};

int main()
{
    int choice;
    Graph obj;
    do
    {
        cout<<"\n1. Create Graph. \n2. Display Graph. \n3. Exit.";
        cout<<"\nEnter your choice: ";
        cin>>choice;
        switch(choice)
        {
            case 1:
                obj.create();
                break;
            case 2:
                obj.display();
                break;
            case 3:
                break;

        }
    }while(choice!=3);
}


                                             //Assignment no. 7

/*Represent given graph using adjacency matrix/list to perform DFS and adjacency list to perform BFS. Use map of area around the 
college as a graph. Identify prominent landmark as nodes and perform DFS and BFS on that.*/

#include <iostream>
#include <stdlib.h>
using namespace std;
int cost[10][10], i, j, k, n, qu[10], front, rear, v, visit[10], visited[10];
int stk[10], top, visit1[10], visited1[10];
int main()
{
    int m;
    cout << "Enter number of vertices : ";
    cin >> n;
    cout << "Enter number of edges : ";
    cin >> m;
    
    cout << "\nEDGES :\n";
    for (k = 1; k <= m; k++)
    {
        cin >> i >> j;
        cost[i][j] = 1;
        cost[j][i] = 1;
    }
    
    //display function
    cout << "The adjacency matrix of the graph is : " << endl;
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            cout << " " << cost[i][j];
        }
        cout << endl;
    }
    cout << "Enter initial vertex : ";
    cin >> v;
    cout << "The BFS of the Graph is\n";
    cout << v<<endl;
    visited[v] = 1;
    k = 1;
    while (k < n)
    {
        for (j = 1; j <= n; j++)
            if (cost[v][j] != 0 && visited[j] != 1 && visit[j] != 1)
            {
                visit[j] = 1;
                qu[rear++] = j;
            }
        v = qu[front++];
        cout << v << " ";
        k++;
        visit[v] = 0;
        visited[v] = 1;
    }
    
    cout <<endl<<"Enter initial vertex : ";
    cin >> v;
    cout << "The DFS of the Graph is\n";
    cout << v<<endl;
    visited[v] = 1;
    k = 1;
    while (k < n)
    {
        for (j = n; j >= 1; j--)
            if (cost[v][j] != 0 && visited1[j] != 1 && visit1[j] != 1)
            {
                visit1[j] = 1;
                stk[top] = j;
                top++;
            }
        v = stk[--top];
        cout << v << " ";
        k++;
        visit1[v] = 0;
        visited1[v] = 1;
    }
     return 0;
}

                                                   

                                     //Assignment no. 8

/*Implement all the functions of a dictionary (ADT) using hashing.
Data: Set of (key, value) pairs, Keys are mapped to values, Keys must be comparable, Keys must be unique.
Standard Operations: Insert(key, value), Find(key), Delete(key) */

#include<iostream>
#include<string.h>
using namespace std;
class HashFunction
  {
    	 public:
    	 typedef struct hash
    	 {
    	     long long key;
    	     char name[10];
 		 }hash;
         hash h[10];

         HashFunction();
         void insert();
         void display();
         int find(long);
         void Delete(long);
  };
HashFunction::HashFunction()
  {
 	int i;
 	for(i=0;i<10;i++)
  	 {
  		h[i].key=-1;
  		strcpy(h[i].name,"NULL");
  	 }
  }
void HashFunction::Delete(long k)
  {
 int index=find(k);
 if(index==-1)
  	 {
  cout<<"\n\tKey Not Found";
  	 }
 else
  	 {
  		h[index].key=-1;
  		strcpy(h[index].name,"NULL");
  cout<<"\n\tKey is Deleted";
  	 }
  }
int HashFunction::find(long k)
  {
 	int i;
 	for(i=0;i<10;i++)
   	{
 		 if(h[i].key==k)
    		{
cout<<"\n\t"<<h[i].key<<" is Found at "<<i<<" Location With Name "<<h[i].name;
  		 return i;
  	 	 }
  	 }
 if(i==10)
     	 {
  		return -1;
   }
  }
void HashFunction::display()
  {
 	int i;
 	cout<<"\n\t\tKey\t\tName";
 	for(i=0;i<10;i++)
   	 {
 		 cout<<"\n\th["<<i<<"]\t"<<h[i].key<<"\t\t"<<h[i].name;
  	 }
  }
void HashFunction::insert()
  {
 	char ans,n[10],ntemp[10];
 	long k,temp;
 int v,hi,cnt=0,flag=0,i;
 do
   	{
 		 if(cnt>=10)
    		{
   			cout<<"\n\tHash Table is FULL";
  		 	break;
   		 }
  		cout<<"\n\tEnter a Telephone No: ";
 		 cin>>k;
 		 cout<<"\n\tEnter a Client Name: ";
 		 cin>>n;
  		hi=k%10;// hash function
  		if(h[hi].key==-1)
  		  {
   			h[hi].key=k;
  			 strcpy(h[hi].name,n);
   		 }
      		else
     		{
  			 if(h[hi].key%10!=hi)
     			{
   				 temp=h[hi].key;
    				strcpy(ntemp,h[hi].name);
    				h[hi].key=k;
    				strcpy(h[hi].name,n);
  				for(i=hi+1;i<10;i++)
       				 {
    					 if(h[i].key==-1)
       					  {
      						h[i].key=temp;
      						strcpy(h[i].name,ntemp);
      						flag=1;
      						break;
          					}
       				 }
    				for(i=0;i<hi && flag==0;i++)
        				{
   					if(h[i].key==-1)
         					{
      						h[i].key=temp;
      						strcpy(h[i].name,ntemp);
      						break;
         					 }
            				}
     			 }
   			else
    			{
    				for(i=hi+1;i<10;i++)
       				{
     					if(h[i].key==-1)
        					 {
     						 h[i].key=k;
      						strcpy(h[i].name,n);
     						 flag=1;
      						break;
         					 }
        				}
   				for(i=0;i<hi && flag==0;i++)
       				 {
     					if(h[i].key==-1)
         					{
     						 h[i].key=k;
     						 strcpy(h[i].name,n);
     						 break;
         					 }
        				  }
     			}
   		 }
     	 	flag=0;
      		cnt++;
      		cout<<"\n\t..... Do You Want to Insert More Key: y/n";
      		cin>>ans;
   	}while(ans=='y'||ans=='Y');
  }
int main()
  {
 long k;
 int ch,index;
 char ans;
 HashFunction obj;
 	do
 	  {
 		 cout<<"\n\t*** Telephone (ADT) *****";
  		cout<<"\n\t1. Insert\n\t2. Display\n\t3. Find\n\t4. Delete\n\t5. Exit";
  		cout<<"\n\t..... Enter Your Choice: ";
 		 cin>>ch;
 		 switch(ch)
    		{
   			case 1:  obj.insert();
     				break;
   			case 2: obj.display();
   				  break;
   			case 3: cout<<"\n\tEnter a Key Which You Want to Search: ";
    				 cin>>k;
     				index=obj.find(k);
     				if(index==-1)
      				 {
      					cout<<"\n\tKey Not Found";
      				}
    				 break;
   			case 4: cout<<"\n\tEnter a Key Which You Want to Delete: ";
   				  cin>>k;
    				 obj.Delete(k);
    				 break;
   			case 5:
   				  break;
    		}
  		cout<<"\n\t..... Do You Want to Continue in Main Menu:y/n ";
  		cin>>ans;
  	 }while(ans=='y'||ans=='Y');
  }



                                                //Assignment no. 9

/*Implement the Heap/Shell sort algorithm implemented in Java demonstrating heap/shell data structure with modularity of 
programming language.*/

public class HeapSort { public void sort(int arr[])
{
int n = arr.length;

// Build heap (rearrange array) for (int i = n / 2 - 1; i >= 0; i--)
heapify(arr, n, i);

// One by one extract an element from heap for (int i = n - 1; i > 0; i--) {
// Move current root to end int temp = arr[0];
arr[0] = arr[i]; arr[i] = temp;

// call max heapify on the reduced heap heapify(arr, i, 0);
}
}

// To heapify a subtree rooted with node i which is
// an index in arr[]. n is size of heap void heapify(int arr[], int n, int i)
{
int largest = i; // Initialize largest as root int l = 2 * i + 1; // left = 2*i + 1
int r = 2 * i + 2; // right = 2*i + 2

// If left child is larger than root if (l < n && arr[l] > arr[largest])
largest = l;

// If right child is larger than largest so far if (r < n && arr[r] > arr[largest])
largest = r;

// If largest is not root if (largest != i) {
int swap = arr[i];
 
arr[i] = arr[largest]; arr[largest] = swap;

// Recursively heapify the affected sub-tree heapify(arr, n, largest);
}
}

/* A utility function to print array of size n */ static void printArray(int arr[])
{
int n = arr.length;
for (int i = 0; i < n; ++i) System.out.print(arr[i] + " ");
System.out.println();
}

// Driver code
public static void main(String args[])
{
int arr[] = { 12, 11, 13, 5, 6, 7 };
int n = arr.length;

HeapSort ob = new HeapSort(); ob.sort(arr);

System.out.println("Sorted array is"); printArray(arr);
}
}


                                                    //Assignment no. 10

/*A Dictionary stores keywords and its meanings. Provide facility for adding new keywords, deleting keywords, updating values of 
any entry. Provide facility to display whole data sorted in ascending/ Descending order. Also find how many maximum comparisons 
may require for finding any keyword. Use Height balance tree and find the complexity for finding a keyword*/



#include<iostream>
#include<string.h>
using namespace std;
class dict
{
    dict *root,*node,*left,*right,*tree1;
    string s1,s2;
    int flag,flag1,flag2,flag3,cmp;
public:
    dict()
    {
        flag=0,flag1=0,flag2=0,flag3=0,cmp=0;
        root=NULL;
    }
    void input();
    void create_root(dict*,dict*);
    void check_same(dict*,dict*);
    void input_display();
    void display(dict*);
    void input_remove();
    dict* remove(dict*,string);
    dict* findmin(dict*);
    void input_find();
    dict* find(dict*,string);
    void input_update();
    dict* update(dict*,string);
   
};

		void dict::input()
		{
			   node=new dict;
			   cout<<"\nEnter the keyword:\n";
			   cin>>node->s1;
			   cout<<"Enter the meaning of the keyword:\n";
			   cin.ignore();
			   getline(cin,node->s2);
			   create_root(root,node);
		}


				void dict::create_root(dict *tree,dict *node1)
				{
				    int i=0,result;
				    char a[20],b[20];
				    if(root==NULL)
				    {
				        root=new dict;
				        root=node1;
				        root->left=NULL;
				        root->right=NULL;
				        cout<<"\nRoot node created successfully"<<endl;
				        return;
				    }
				    for(i=0;node1->s1[i]!='\0';i++)
				    {
				    	a[i]=node1->s1[i];
				    }
				    for(i=0;tree->s1[i]!='\0';i++)
				    {
				    	b[i]=tree->s1[i];
				    }
				    result=strcmp(b,a);
				    check_same(tree,node1);
				    if(flag==1)
				        {
				            cout<<"The word you entered already exists.\n";
				            flag=0;
				        }
				        else
				        {
				    if(result>0)
				    {
				        if(tree->left!=NULL)
				        {
				            create_root(tree->left,node1);
				        }
				        else
				        {
				            tree->left=node1;
				            (tree->left)->left=NULL;
            				    (tree->left)->right=NULL;
            				cout<<"Node added to left of "<<tree->s1<<"\n";
            				return;
 				       }				
    				    }
    				    else if(result<0)
    				    {
        				 if(tree->right!=NULL)
        				 {
        				     create_root(tree->right,node1);
        				 }
        				 else
        				 {
        				     tree->right=node1;
        				     (tree->right)->left=NULL;
        				     (tree->right)->right=NULL;
        				     cout<<"Node added to right of "<<tree->s1<<"\n";
        				     return;
        				 }
    				    }			
    				         }
				    }


void dict::check_same(dict *tree,dict *node1)
{
	if(tree->s1==node1->s1)
	{
		flag=1;
		return;
	}
	else if(tree->s1>node1->s1)
     {
	 if(tree->left!=NULL)
	{
    	 check_same(tree->left,node1);
	}
     }
     else if(tree->s1<node1->s1)
     {
    	 if(tree->right!=NULL)
    	 {
    	 check_same(tree->right,node1);
    	 }
     }
}
		

		void dict::input_display()
		{
			if(root!=NULL)
			{
		    	cout<<"The words entered in the dictionary are:\n\n";
		    	display(root);
			}
			else
			{
		        cout<<"\nThere are no words in the dictionary.\n";
			}
		}
		

				void dict::display(dict *tree)
				{
				    	if(tree->left==NULL&&tree->right==NULL)
				    	{
				    		cout<<tree->s1<<" = "<<tree->s2<<"\n\n";
				    	}
				    	else
				    	{
				        if(tree->left!=NULL)
				        {
				        	display(tree->left);
				        }
				        cout<<tree->s1<<" = "<<tree->s2<<"\n\n";
				        if(tree->right!=NULL)
				        {
				        	display(tree->right);
				        }
				    	}
				}


void dict::input_remove()
{
	char t;
	if(root!=NULL)
	{
	  cout<<"\nEnter a keyword to be deleted:\n";
	  cin>>s1;
	  remove(root,s1);
	  if(flag1==0)
	  {
	    	cout<<"\nThe word '"<<s1<<"' has been deleted.\n";
	  }
	  flag1=0;
	}
	else
	{
		cout<<"\nThere are no words in the dictionary.\n";
	}
}


		dict* dict::remove(dict *tree,string s3)
		{
			dict *temp;
		    if(tree==NULL)
		    {
		    	cout<<"\nWord not found.\n";
		    	flag1=1;
		    	return tree;
		    }
		    else if(tree->s1>s3)
		    {
		    	tree->left=remove(tree->left,s3);
		    	return tree;
		    }
		    else if(tree->s1<s3)
			    {
		    	tree->right=remove(tree->right,s3);
		    	return tree;
		    }
		    else
		    {
		    	if(tree->left==NULL&&tree->right==NULL)
		    	{
		    		delete tree;
		    		tree=NULL;
		    	}
		    	else if(tree->left==NULL)
		    	{
		    		temp=tree;
		    		tree=tree->right;
		    		delete temp;
		    	}
		    	else if(tree->right==NULL)
		    	{
		    		temp=tree;
		    		tree=tree->left;
		    		delete temp;
    			}		
    			else
    			{
    				temp=findmin(tree->right);
    				tree=temp;
    				tree->right=remove(tree->right,temp->s1);
    			}
    		}
    		return tree;
		}


				dict* dict::findmin(dict *tree)
				{
					while(tree->left!=NULL)
					{
						tree=tree->left;
					}
					return tree;
				}		


		void dict::input_find()
		{
			flag2=0,cmp=0;
			if(root!=NULL)
			{
			cout<<"\nEnter the keyword to be searched:\n";
			cin>>s1;
		    find(root,s1);
		    if(flag2==0)
		    {
				cout<<"Number of comparisons needed: "<<cmp<<"\n";
				cmp=0;
		    }
			}
			else
			{
				cout<<"\nThere are no words in the dictionary.\n";
			}
		}


				dict* dict::find(dict *tree,string s3)
				{
					if(tree==NULL)
					{
						cout<<"\nWord not found.\n";
						flag2=1;
						flag3=1;
						cmp=0;
					}
					else
					{
						if(tree->s1==s3)		
						{			
							cmp++;
							cout<<"\nWord found.\n";
							cout<<tree->s1<<": "<<tree->s2<<"\n";
							tree1=tree;
							return tree;
						}
						else if(tree->s1>s3)
						{
							cmp++;
							find(tree->left,s3);
						}
						else if(tree->s1<s3)
						{
							cmp++;
							find(tree->right,s3);
						}
					}		
					return tree;
	                        }


void dict::input_update()
{
	if(root!=NULL)
	{
	cout<<"\nEnter the keyword to be updated:\n";
	cin>>s1;
    update(root,s1);
	}
	else
	{
		cout<<"\nThere are no words in the dictionary.\n";
	}
}


		dict* dict::update(dict *tree,string s3)
		{
			flag3=0;
			find(tree,s3);
			if(flag3==0)
			{
		    cout<<"\nEnter the updated meaning of the keyword:\n";
		    cin.ignore();
		    getline(cin,tree1->s2);
		    cout<<"\nThe meaning of '"<<s3<<"' has been updated.\n";
			}
		    return tree;
		}





				int main()
				  {
				    int ch;
				    dict d;
				    do
				    {
				    cout<<"\n==========================================\n"
				    	  "\n***DICTIONARY****:\n"
    	 				 "\nEnter your choice:\n"
         				 "1.Add new keyword.\n"
         				 "2.Display the contents of the Dictionary.\n"
    	 				 "3.Delete a keyword.\n"
    	 				 "4.Find a keyword.\n"
    	 				 "5.Update the meaning of a keyword.\n"
    	 				 "6.Exit.\n"
    	 				 "===============================================\n";
    				cin>>ch;
    				switch(ch)
    				{
    				    case 1:d.input();
    				           break;
    				    case 2:d.input_display();
    				    	   break;
    				    case 3:d.input_remove();
    				           break;
    				    case 4:d.input_find();
    				           break;
    				    case 5:d.input_update();
    				    	   break;
    				    default:cout<<"\nPlease enter a valid option!\n";
    				    	    break;
    				}
    				  }while(ch!=6);
    				return 0;
				}    



                                         //Assignment no. 11

/*Given sequence k = k1 <k2 < … <kn of n sorted keys, with a search probability pi for each 
key ki . Build the Binary search tree that has the least search cost given the access 
probability for each key?*/


#include<iostream>
using namespace std;
class Onode
{
	Onode *left,*right;
	int key;
	public:
	friend class OBST;
};
class OBST
{
	int cntk;
	int **klist;
	int **mat;
	Onode *root1;
	public:
	void create();
	Onode* insert(int,int);
	void pre(Onode*);
	void in(Onode *);
	Onode* getroot(){return(root1);}
};
void OBST::pre(Onode *r)
{
	if(r!=NULL)
	{
		cout<<r->key<<"\t";
		pre(r->left);
		pre(r->right);
	}
}
void OBST::in(Onode *r)
{
	if(r!=NULL)
	{
		in(r->left);
		cout<<r->key<<"\t";
		in(r->right);
	}
}
Onode* OBST::insert(int i,int j)
{
	int k=mat[i][j];
	Onode *p=new Onode;
	cout<<k<<endl;
	if(i==j)
	{
		p->left=p->right=NULL;
		p->key=klist[i][0];
	}
	else
	{
		p->key=klist[k][0];
		if(k>j)
		p->left=insert(k-1,j);
		else
		p->left=NULL;
		if(k<i)
		p->right=insert(i,k+1);
		else
		p->right=NULL;
	}
	return(p);
}
void OBST::create()
{
	int k,i,j,l,a,min,root;
	cout<<"Enter number of keys."<<endl;
	cin>>cntk;
	cout<<"Enter values of "<<cntk<<" keys and their search probabilities respectively."<<endl;
	klist=new int*[cntk];
	for(k=0;k<cntk;k++)
	{
		cout<<"key"<<k<<":"<<endl;
		klist[k]=new int[2];
		cin>>klist[k][0]>>klist[k][1];
	}
	mat=new int*[cntk];
	for(k=0;k<cntk;k++)
		mat[k]=new int[cntk];
	for(k=0;k<cntk;k++)
		mat[k][k]=klist[k][1];
	for(k=1;k<cntk;k++)
	{
		for(i=0;i<cntk-k;i++)
		{
			mat[i][i+k]=0;
			for(j=i;j<=i+k;j++)
				mat[i][i+k]+=mat[j][j];
			min=9999;
			for(j=i;j<=i+k;j++)
			{
				a=0;
				if(j-1>=i)
					a+=mat[i][j-1];
				if(j+1<=i+k)
					a+=mat[j+1][i+k];
				if(min>a)
				{
					min=a;
					root=j;
				}
			}
			mat[i][i+k]+=min;
			mat[i+k][i]=root;
		}
		
	}
	for(i=0;i<cntk;i++)
		{
			for(j=0;j<cntk;j++)
				cout<<mat[i][j]<<"\t";
			cout<<endl;
		}
	root1=insert(cntk-1,0);
	
}
int main()
{
OBST o;
o.create();
cout<<"Preorder Traversal."<<endl;
o.pre(o.getroot());
cout<<endl<<"Inorder Traversal."<<endl;
o.in(o.getroot());
return 0;
}





/*                                        Assignment N0 : 12
Problem Statement: Company maintains employee information as employee ID, name, designation and salary. Allow user to add,
delete information of employee. Display information of particular employee. If employee does not exist an appropriate
message is displayed. If it is, then the system displays the employee details. Use index sequential file to maintain the
data.*/


#include<iostream>
#include<fstream>
#include<string>
using namespace std;
class Employee
{
    int id;
    char name[30];
    char desg[30];
    long int salary;
    public:
    void setData()
    {
        cout<<"\nEnter employee ID: \t";
        cin>>id;
        cout<<"\nEnter employee name:\t";
        cin>>name;
        cout<<"\nEnter designation :\t";
        cin>>desg;
        cout<<"\nEnter salary:\t";
        cin>>salary;
    }
    void get()
    {
        cout<<"\n"<<id<<"\t"<<name<<"\t"<<desg<<"\t"<<salary<<"\t";
    }
    int retId()
    {
        return id;
    }
};
void addRecord()
{
    ofstream out;
    out.open("employee.dat",ios::binary|ios::app);
    Employee obj;
    obj.setData();
    out.write((char*)&obj,sizeof(obj));
    out.close();
    cout<<"Data Entered successfully !!!!";
}
void search(int a)
{
    int flag=0;
    ifstream in;
    in.open("employee.dat",ios::binary);
    Employee obj;
    while(in.read((char*)&obj,sizeof(obj)))
    {
        if(obj.retId()==a)
        {
            cout<<"\nEmpID \t Empnm\t Desg \tSalary\t";
            obj.get();
            flag=1;
            break;
        }
    }
    if(flag==0)
    {
        cout<<"Record not found !!!!";
    }
    in.close();
}
void dispRecord()
{
    Employee obj;
    ifstream in;
    in.open("employee.dat",ios::binary);
    while(in.read((char*)&obj, sizeof(obj)))
    {
        obj.get();
    }
    in.close();
}
void delRecord(int a)
{
    int flg=0;
    ifstream in;
    ofstream out;
    in.open("employee.dat",ios::binary);
    Employee obj;
    while(in.read((char*)&obj,sizeof(obj)))
    {
        if(obj.retId()==a)
        {
            flg=1;
            cout<<"Record found .......deleting";
            break;
        }
        else
        {
            cout<<"Record does not exists";
        }
    }
    if(flg==1)
    {
        out.open("temp.dat",ios::out|ios::binary);
        while(in.read((char*)&obj,sizeof(obj)))
        {
            if(obj.retId()!=a)
            {
                out.write((char*)&obj,sizeof(obj));
            }
        }
        in.close();
        out.close();
        remove("employee.dat");
        rename("temp.dat","employee.dat");
    }
}
int main()
{
    int ch,n,key;
    do
    {
        cout<<"\nMENU:\t"<<"\n 1. ADD \n 2.DISPLAY \n 3.SEARCH \n 4.DELETE \n5.Exit";
        cout<<"\nEnter your choice: \t";
        cin>>ch;
        switch(ch)
        {
            case 1:
                cout<<"enter the no. of records you want to insert:\t";
                cin>>n;
                for(int i=0;i<n;i++)
                {
                    addRecord();
                }
                break;
            case 2:
                cout<<"\n THE DATA IN THE FILE IS::\n";
                cout<<"\nEmpID \t Empnm\t Desg \tSalary\t";
                dispRecord();
                break;
            case 3:
                cout<<"Enter employee ID you want to search:\t";
                cin>>key;
                search(key);
                break;
            case 4:
                cout<<"Enter employee id you want to delete:\t";
                cin>>key;
                delRecord(key);
                cout<<"\nRecord deleted";
                break;
            case 5:
                return 0;
        }
    }while(ch!=5);
}
                                                
Assignment 2 
//skip list

import random 
  
class Node: 
    
    def __init__(self, key, level): 
        self.key = key 
		# list to hold addresses to node of different level
        self.next = [None]*(level+1) 
  
class SkipList: 
   
    def __init__(self, max_lvl, P):        
		# Maximum level for this skip list 
		    self.MAXLVL = max_lvl 

		# P is the fraction of the nodes with level 
		# i references also having level i+1 references 
		    self.P = P 

		# create header node and initialize key to -1 
		    self.header = self.createNode(self.MAXLVL, -1) 

		# current level of skip list 
		    self.level = 0
		
     # Create new node 
    def createNode(self, lvl, key): 
        n = Node(key, lvl) 
        return n 
     
	 # create random level for node
    def randomLevel(self): 
        lvl = 0
        while random.random()<self.P and lvl<self.MAXLVL:
              lvl += 1
        return lvl 
		
    # Insert key
    def insertElement(self, key): 
        update = [None]*(self.MAXLVL+1) 
        current = self.header 
  
        ''' 
        start from highest level of skip list move the current reference forward while key  
        is greater than key of node next to current 
		Otherwise inserted current in update and move one level down and continue search 
        '''
        for i in range(self.level, -1, -1): 
            while current.next[i] and current.next[i].key < key: 
                current = current.next[i] 
            update[i] = current 
  
       #level 0 is reached and forward refernce to right which is the correct position for insertion
        current = current.next[0] 
  
        ''' 
        if current is NULL that means we have reached to end of the level or current's key is not equal 
           to key to insert that means we have to insert node between update[0] and current node 
       '''
        if current == None or current.key != key: 
            rlevel = self.randomLevel() 
  
            ''' 
            If random level is greater than list's current level (node with highest level inserted in  
            list so far), initialize update value with reference to header for further use 
            '''
            if rlevel > self.level: 
                for i in range(self.level+1, rlevel+1): 
                    update[i] = self.header 
                self.level = rlevel 
  
            n = self.createNode(rlevel, key) 
			
            #insert the node and update all references
            for i in range(rlevel+1): 
                n.next[i] = update[i].next[i] 
                update[i].next[i] = n 
  
            print("Successfully inserted key {}".format(key)) 
 
    #Search the element
    def searchElement(self, key):  
        current = self.header 

        for i in range(self.level, -1, -1): 
            while(current.next[i] and current.next[i].key < key): 
                current = current.next[i] 
  
        current = current.next[0] 
  
        if current and current.key == key: 
            print("Entered Key Found ", key) 
        else:
            print("Entered Key Not Found ")
  
  
    # Display the list levelwise
    def displayList(self): 
        print("\nSkip List Is : ") 
        head = self.header 
        for lvl in range(self.level+1): 
            print("Level {}: ".format(lvl), end=" ") 
            node = head.next[lvl] 
            while(node != None): 
                print(node.key, end=" ") 
                node = node.next[lvl] 
            print("") 
  
def main(): 
    lst = SkipList(3, 0.5) 
    
    n=int(input("Enter total number of element"))

    for i in range(0,n):
        temp=int(input("Enter the Element"))
        lst.insertElement(temp)

    lst.displayList() 
  
    temp=int(input("Enter Element for searching"))
    lst.searchElement(temp) 
main()





Assignment 5
//threaded binary tree

#include<iostream>
#include<stdlib.h>
using namespace std;
struct node
{
    int data;
    node *left,*right;
    int lbit,rbit;
};
class tbt
{
   node *temp=NULL,*t1=NULL,*s=NULL,*head=NULL,*t=NULL;
   public:
  
   node *create();
   void insert();
   node *insuc(node*);
   node *inpre(node*);
   void dis();
   void display(node*);
   void thr();
   void thread(node*);
};
node *tbt::create()
{
   node *p=new(struct node);
   p->left=NULL;
   p->right=NULL;
   p->lbit=0;
   p->rbit=0;
   cout<<"\n enter the data";
   cin>>p->data;
   return p;
}
void tbt::insert()
{
    temp=create();
    if(head==NULL)
    {  node *p=new(struct node);
       head=p;
       head->left=temp;
       head->right=head;
       head->lbit=1;
       head->rbit=0;
       temp->left=head;
       temp->right=head;
       temp->lbit=0;
       temp->rbit=0;
    }
    else
    {     t1=head;
          t1=t1->left;
        
          while(t1!=NULL)
          {   s=t1; 
              if(((temp->data)>(t1->data))&&t1->rbit==1)
              {   t1=t1->right;   }
              else if(((temp->data)<(t1->data))&&t1->lbit==1)
              {   t1=t1->left;     }
              else
              { break;       }
          }
          if(temp->data>s->data)
          {  
             s->right=temp;
             s->rbit=1;
             temp->left=inpre(head->left);
             temp->right=insuc(head->left);
          }
          else
          {
             s->left=temp;
             s->lbit=1;
             temp->left=inpre(head->left);
             temp->right=insuc(head->left);
          }
     }       
            
            
         
    
}         
node *tbt::inpre(node *m)
{   
    if(m->lbit==1)
    { 
      inpre(m->left);
    }
    if(m->data==temp->data&&t==NULL)
    {  return head;       }
    if(m->data==temp->data)
    {   return t;         }
    t=m;
    if(m->rbit==1)
    { inpre(m->right);
    } 
      
}
node *tbt::insuc(node *m)
{  
    if(m->lbit==1)
    {  t=m;
      insuc(m->left);
    }
   
    if(m->data==temp->data&&t==NULL)
    {  return head;       }
    if(m->data==temp->data)
    {   return t;        }
   
    if(m->rbit==1)
    { insuc(m->right);
    } 
}
void tbt::dis()
{   display(head->left);
}
void tbt::display(node *m)
{
 
       if(m->lbit==1)
       {   display(m->left);              }
       cout<<"\n"<<m->data;
       if(m->rbit==1)
       {    display(m->right);             }
      
     
  
}
void tbt::thr()
{  cout<<"\n thread are";
   thread(head->left);
}
void tbt::thread(node *m)
{
 
       if(m->lbit==1)
       {   thread(m->left);              }
       if(m->lbit==0||m->rbit==0)
       {
       cout<<"\n"<<m->data;
       }
       if(m->rbit==1)
       {    thread(m->right);             }
      
     
  
}  
int main()
{  tbt t;  int ch;
   while(1)
   {
  
   cout<<"\n enter the choice";
   cout<<"\n 1.insert data";
   cout<<"\n 2.display all data";
   cout<<"\n 3.display threaded node";
   cout<<"\n 4.exit";
   cin>>ch;
   switch(ch)
   {
      case 1:
                t.insert();
                break;
      case 2:
                t.dis();
                break;
      case 3:
                t.thr();
                break;
      case 4:  exit(0);
               
      default:
               cout<<"\n invalid entry";
    }             
    }
   return 0;
}          




Assignment 10 

// reading marks using heap

#include <iostream>
using namespace std;
class hp
{
    int heap[20], heap1[20], x, n1, i;

public:
    hp()
    {
        heap[0] = 0;
        heap1[0] = 0;
    }
    void getdata();
    void insert1(int heap[], int);
    void upadjust1(int heap[], int);
    void insert2(int heap1[], int);
    void upadjust2(int heap1[], int);
    void minmax();
};
void hp::getdata()
{
    cout << "\nEnter number of students : ";
    cin >> n1;
    cout << "\nEnter marks of students :";

    for (i = 0; i < n1; i++)
    {
        cout << "\n"
             << i + 1 << " : ";
        cin >> x;
        insert1(heap, x);
        insert2(heap1, x);
    }
}
void hp::insert1(int heap[20], int x)
{
    int n;
    n = heap[0];
    heap[n + 1] = x;
    heap[0] = n + 1;

    upadjust1(heap, n + 1);
}
void hp::upadjust1(int heap[20], int i)
{
    int temp;
    while (i > 1 && heap[i] > heap[i / 2])
    {
        temp = heap[i];
        heap[i] = heap[i / 2];
        heap[i / 2] = temp;
        i = i / 2;
    }
}
void hp::insert2(int heap1[20], int x)
{
    int n;
    n = heap1[0];
    heap1[n + 1] = x;
    heap1[0] = n + 1;

    upadjust2(heap1, n + 1);
}
void hp::upadjust2(int heap1[20], int i)
{
    int temp1;
    while (i > 1 && heap1[i] < heap1[i / 2])
    {
        temp1 = heap1[i];
        heap1[i] = heap1[i / 2];
        heap1[i / 2] = temp1;
        i = i / 2;
    }
}
void hp::minmax()
{
    cout << "\nMax marks : " << heap[1];
    for (i = 0; i <= n1; i++)
        cout << "\n"
             << heap[i];
    cout << "\nMin marks : " << heap1[1];
    for (i = 0; i <= n1; i++)
        cout << "\n"
             << heap1[i];
}
int main()
{
    hp h;
    h.getdata();
    h.minmax();
    return 0;
}
